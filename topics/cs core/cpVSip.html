<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Premordium: The Foundation of Code</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link rel="icon" type="image/svg+xml" href="/asset/icons/books (2).svg" />
    <link rel="stylesheet" href="/styles/index.css" />
    <link rel="stylesheet" href="/styles/cpVSip.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700&display=swap"
    />
  </head>
  <body>
    <h1><a href="/index.html">Premordium</a></h1>
    <h2><a href="/index.html">The Foundation of Code</a></h2>
    <br />

    <h5 class="ocw">OpenCourseWare</h5>

    <br />
    <h5>Hassan2bit</h5>
    <h5>
      <a href="mailto:hassanamiri.ai@gmail.com">hassanamiri.ai@gmail.com</a>
    </h5>
    <a href="https://x.com/HassanAmiriiii" target="_blank">
      <img
        src="/asset/logos/x-logo-thin.png"
        alt="X icon"
        width="20"
        height="20"
      />
    </a>
    <a
      href="https://github.com/HassanAmirii/premordium-the-foundation-of-code "
      target="_blank"
    >
      <img
        src="/asset/logos/github-logo-thin.png"
        alt="github icon"
        width="20"
        height="20"
      />
    </a>

    <br />
    <br />

    <h1>Compilers vs Interpreters</h1>
    <hr />
    <div class="container">
      <ul>
        <li>
          <strong
            ><a href="#definition-and-purpose"
              >Definition and Purpose</a
            ></strong
          >
          <ul>
            <li>
              <a href="#understanding-compilers"
                >Understanding what compilers
              </a>
            </li>

            <li>
              <a href="#understanding-interpreters"
                >Understanding what interpreters
              </a>
            </li>
          </ul>
        </li>
        <br />

        <li>
          <strong
            ><a href="#translation-process">Translation Process</a></strong
          >
        </li>
        <br />

        <li>
          <strong
            ><a href="#pros-cons"
              >Pros & Cons: Compiler vs Interpreter</a
            ></strong
          >
        </li>
        <br />

        <li>
          <strong><a href="#use-cases">Use Cases</a></strong>
          <ul>
            <li>
              <a href="#compilers-use-cases">Compilers </a>
            </li>
            <li>
              <a href="#interpreters-use-cases">Interpreters </a>
            </li>
          </ul>
        </li>
        <br />

        <li>
          <strong><a href="#historical-context">Historical Context</a></strong>
          <ul>
            <li>
              <a href="#origins-compilers-interpreters"
                >The origins and evolution of compilers and interpreters</a
              >
            </li>
          </ul>
        </li>
      </ul>
      <br /><br /><br />

      <h1 id="definition-and-purpose">Definition and Purpose</h1>
      <hr />
      <br />

      <!-- the Notes  -->
      <p>
        Have you wondered how a computer understands human readable code?
        Because as you and I both know, the only things a computer understands
        are just <span class="color-green">1s and 0s</span>. Take a look at the
        Python code below.
      </p>
      <br />
      <div class="code-design">
        <pre class="python-code">
        <code >
        A = 1
        B = 2

        print(f"i have {A + B} apples")
        </code>

        output: i have 3 apples
      </pre>
      </div>
      <br />

      <p>
        The code above is simply easy to understand right, even for a
        non-technical person. But this syntax is pretty much gibberish to the
        computer, because it only understands
        <span class="color-green">1s and 0s</span>.
      </p>
      <br />
      <p>
        The solution we've got now is to find a way to make the computer
        understand our gibberish. That is, we need to find a way to turn our
        code into
        <span class="color-green">1s and 0s</span> (machine language).
      </p>

      <br /><br />

      <h1 id="understanding-compilers">Understanding Compilers</h1>
      <hr />
      <br />

      <p>
        Now one of the ways we can convert our code into machine readable
        language is to use a compiler language.
      </p>
      <br />
      <p>
        Let's take for example, you are in a restaurant. A waiter approached and
        handed you a pen and piece of paper to write down your order, and you
        wrote:
      </p>

      <br />
      <pre class="order-card"> 
        <p>order list</p>
        <ul>
        <li>sharwama + beef</li>
        <li>a large piece of bread</li>
        <li>honey and butter</li>
        <li>pizza and spaghetti</li>
        <li>a human medium fried liver</li>
        <li>fufu and garri....</li>
        </ul>
      </pre>
      <br />

      <p>
        Now since your waiter here is a compiler, he's going to pile up your
        order list, give it to the chef to cook at once, and bring you back your
        full order. Now that must be pretty fast right? Because all your orders
        are processed at the same time.
      </p>
      <br />
      <p>
        So basically whenever you are using a compiler language, your code is
        processed through compiling into an executable file (<span
          class="color-green"
          >1s and 0s</span
        >), and it gives you back the output.
      </p>

      <br /><br />

      <h1 id="understanding-interpreters">Understanding Interpreters</h1>
      <hr />
      <br />

      <p>
        An interpreter language is also another interesting way we can convert
        our code to binary (machine language). We could also use the waiter and
        the chef story to simplify this.
      </p>
      <br />
      <p>
        So again you are at a restaurant and approached by a waiter. A pen and a
        piece of paper was handed to you to write down your order:
      </p>

      <br />
      <pre class="order-card"> 
        <p>order list</p>
        <ul>
        <li>Biscuit</li>
        <li>Bread</li>
        <li>Yam</li>
        </ul>
      </pre>
      <br />

      <p>
        Now because you are dealing with an interpreter waiter, your order won't
        be processed at once, rather one after the other. That is, the waiter
        will take the first order on the list which is biscuit here, give it to
        the chef to prepare, deliver the order and repeat, until it finishes
        processing the last order - quite slow compared to the compiler waiter
        which processed our order at once.
      </p>
      <br />
      <p>
        So in summary, an interpreter language takes our code and converts it
        into machine code line by line every time we run it.
      </p>

      <br /><br />

      <h1 id="translation-process">Translation Process</h1>
      <hr />
      <br />

      <p>So how does the translation actually happen? The process involves:</p>
      <br />
      <p>
        <strong>#analysation</strong><br />
        We'd need an interpreter or a compiler to analyze our code for syntax
        errors.
      </p>
      <br />
      <p>
        <strong>#optimization</strong><br />
        Further, our code will then be optimized through better structuring so
        as to use less memory.
      </p>
      <br />
      <p>
        <strong>#conversion</strong><br />
        Once that is done, if it's a compiler, our code will be converted into
        byte code. Think of byte code as a code that supports any hardware
        component. After that, it's converted into an executable file (<span
          class="color-green"
          >1s & 0s</span
        >). And for a compiler, once it has converted into an executable file
        once, it doesn't have to process anything whenever you run it, it just
        loads pfwee.
      </p>
      <br />
      <p>
        Whereas if it was an interpreter language, our code will be converted to
        machine language line by line every single time we run it.
      </p>
      <!-- #embed that video yt + credit or just a link -->

      <br /><br />

      <h1 id="pros-cons">Pros & Cons: Compiler vs Interpreter</h1>
      <hr />
      <br />

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Feature</th>
            <th>Compiler</th>
            <th>Interpreter</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Execution speed</td>
            <td>Faster (entire code compiled once)</td>
            <td>Slower (line by line execution)</td>
          </tr>
          <tr>
            <td>Memory usage</td>
            <td>Higher (needs to store entire compiled program)</td>
            <td>Lower (only loads what's currently needed)</td>
          </tr>
          <tr>
            <td>Error handling</td>
            <td>All errors found before execution</td>
            <td>Stops at first error during execution</td>
          </tr>
          <tr>
            <td>Debugging</td>
            <td>More difficult (separate compilation step)</td>
            <td>Easier (immediate feedback)</td>
          </tr>
          <tr>
            <td>Flexibility</td>
            <td>Less flexible (needs recompilation)</td>
            <td>More flexible (can change code on the fly)</td>
          </tr>
          <tr>
            <td>Optimization</td>
            <td>Better (more time to optimize)</td>
            <td>Limited (optimizes on the go)</td>
          </tr>
          <tr>
            <td>Real-time execution</td>
            <td>No (compilation step first)</td>
            <td>Yes (immediate execution)</td>
          </tr>
        </tbody>
      </table>

      <h1 id="use-cases">Use Cases</h1>
      <hr />
      <br />

      <h1 id="compilers-use-cases">Compilers Use Cases</h1>
      <hr />
      <br />

      <p>
        When should you use
        <a
          href="https://en.wikipedia.org/wiki/Compiled_language"
          target="_blank"
          title="Compiled languages convert source code to machine code before execution"
          >compiled languages</a
        >? Here are the main situations:
      </p>
      <br />

      <ul>
        <li>
          <strong>Speed matters</strong>: Games,
          <a
            href="https://en.wikipedia.org/wiki/Operating_system"
            target="_blank"
            title="Software that manages computer hardware and software resources"
            >operating systems</a
          >, and other performance-critical software
        </li>
        <li>
          <strong>Limited resources</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Embedded_system"
            target="_blank"
            title="Computing systems built into devices with specific functions"
            >Embedded systems</a
          >
          and
          <a
            href="https://en.wikipedia.org/wiki/Internet_of_things"
            target="_blank"
            title="Internet of Things - connected smart devices"
            >IoT devices</a
          >
          with minimal memory
        </li>
        <li>
          <strong>Distributing software</strong>: When you want users to run
          your program without seeing your code
        </li>
      </ul>

      <br />
      <p>Common compiled languages: C, C++, Rust, Go</p>

      <br /><br />

      <h1 id="interpreters-use-cases">Interpreters Use Cases</h1>
      <hr />
      <br />

      <p>
        When do you
        <a
          href="https://en.wikipedia.org/wiki/Interpreter_(computing)"
          target="_blank"
          title="Interpreters execute code line by line at runtime"
          >interpreters</a
        >
        ? Here are the main situations:
      </p>
      <br />

      <ul>
        <li>
          <strong>Quick development</strong>: Web development,
          <a
            href="https://en.wikipedia.org/wiki/Software_prototyping"
            target="_blank"
            title="Creating preliminary versions to test concepts"
            >prototyping</a
          >, when you need to test ideas fast
        </li>
        <li>
          <strong>Learning to code</strong>: Getting immediate feedback helps
          beginners
        </li>
        <li>
          <strong>Scripting</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Task_automation"
            target="_blank"
            title="Using code to automate repetitive tasks"
            >Automation</a
          >
          tasks and simple tools
        </li>
        <li>
          <strong>Cross-platform needs</strong>: When your code needs to run on
          different systems easily
        </li>
      </ul>

      <br />
      <p>Common interpreted languages: Python, JavaScript, Ruby, PHP</p>

      <br /><br />

      <h1 id="historical-context">Historical Context</h1>
      <hr />
      <br />

      <h1 id="origins-compilers-interpreters">The Origins and Evolution</h1>
      <hr />
      <br />

      <p>How did we get here? A quick history:</p>
      <br />

      <ul>
        <li>
          <strong>1950s</strong>: First compiler created by
          <a
            href="https://en.wikipedia.org/wiki/Grace_Hopper"
            target="_blank"
            title="Pioneer in computer programming and US Navy rear admiral"
            >Grace Hopper</a
          >
          for the A-0 programming language
        </li>
        <li>
          <strong>1957</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Fortran"
            target="_blank"
            title="FORmula TRANslation - early high-level programming language"
            >FORTRAN</a
          >
          compiler released - first widely used high-level language
        </li>
        <li>
          <strong>1960s</strong>:
          <a
            href="https://en.wikipedia.org/wiki/BASIC"
            target="_blank"
            title="Beginner's All-purpose Symbolic Instruction Code"
            >BASIC</a
          >
          interpreter made programming accessible to more people
        </li>
        <li>
          <strong>1970s-80s</strong>:
          <a
            href="https://en.wikipedia.org/wiki/C_(programming_language)"
            target="_blank"
            title="General-purpose programming language"
            >C language</a
          >
          compiler became dominant for system programming
        </li>
        <li>
          <strong>1990s</strong>: Java introduced "compile once, run anywhere"
          with
          <a
            href="https://en.wikipedia.org/wiki/Bytecode"
            target="_blank"
            title="Intermediate code form between source code and machine code"
            >bytecode</a
          >
          and a
          <a
            href="https://en.wikipedia.org/wiki/Virtual_machine"
            target="_blank"
            title="Software that creates isolated environment for running programs"
            >virtual machine</a
          >
        </li>
        <li>
          <strong>2000s-now</strong>: Hybrid approaches becoming common (<a
            href="https://en.wikipedia.org/wiki/Just-in-time_compilation"
            target="_blank"
            title="Just-In-Time compilers that compile during execution"
            >JIT compilers</a
          >,
          <a
            href="https://en.wikipedia.org/wiki/Source-to-source_compiler"
            target="_blank"
            title="Tools that convert code from one language to another"
            >transpilers</a
          >)
        </li>
      </ul>

      <br />
      <p>The end :/</p>
    </div>
  </body>
</html>
