<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Premordium: The Foundation of Code</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link rel="icon" type="image/svg+xml" href="/asset/icons/books (2).svg" />
    <link rel="stylesheet" href="/styles/index.css" />
    <link rel="stylesheet" href="/styles/cpVSip.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700&display=swap"
    />
  </head>
  <body>
    <h1><a href="/index.html">Premordium</a></h1>
    <h2><a href="/index.html">The Foundation of Code</a></h2>
    <br />

    <h5 class="ocw">OpenCourseWare</h5>

    <br />
    <h5>Hassan2bit</h5>
    <h5>
      <a href="mailto:hassanamiri.ai@gmail.com">hassanamiri.ai@gmail.com</a>
    </h5>
    <a href="https://x.com/HassanAmiriiii" target="_blank">
      <img
        src="/asset/logos/x-logo-thin.png"
        alt="X icon"
        width="20"
        height="20"
      />
    </a>
    <a
      href="https://github.com/HassanAmirii/premordium-the-foundation-of-code "
      target="_blank"
    >
      <img
        src="/asset/logos/github-logo-thin.png"
        alt="github icon"
        width="20"
        height="20"
      />
    </a>

    <br />
    <br />

    <h1>Compilers vs Interpreters</h1>
    <hr />
    <div class="container">
      <ul>
        <li>
          <strong
            ><a href="#definition-and-purpose"
              >Definition and Purpose</a
            ></strong
          >
          <ul>
            <li>
              <a href="#understanding-compilers"
                >Understanding what compilers
              </a>
            </li>

            <li>
              <a href="#understanding-interpreters"
                >Understanding what interpreters
              </a>
            </li>
          </ul>
        </li>
        <br />

        <li>
          <strong
            ><a href="#translation-process">Translation Process</a></strong
          >
        </li>
        <br />

        <li>
          <strong
            ><a href="#pros-cons"
              >Pros & Cons: Compiler vs Interpreter</a
            ></strong
          >
        </li>
        <br />

        <li>
          <strong><a href="#use-cases">Use Cases</a></strong>
          <ul>
            <li>
              <a href="#compilers-use-cases">Compilers </a>
            </li>
            <li>
              <a href="#interpreters-use-cases">Interpreters </a>
            </li>
          </ul>
        </li>
        <br />

        <li>
          <strong><a href="#historical-context">Historical Context</a></strong>
          <ul>
            <li>
              <a href="#origins-compilers-interpreters"
                >The origins and evolution of compilers and interpreters</a
              >
            </li>
          </ul>
        </li>
      </ul>
      <br /><br /><br />

      <h1 id="definition-and-purpose">Definition and Purpose</h1>
      <hr />
      <br />

      <!-- the Notes  -->
      <p>
        Have you ever wondered how a computer understands human-readable code?
        As you and I both know, the only thing a computer truly understands is
        just
        <span class="color-green">(1s and 0s)</span>. Take a look at the Python
        code below.
      </p>
      <br />
      <div class="code-design">
        <pre class="python-code">
        <code>
      A = 1
      B = 2
      
      print(f"I have {A + B} apples")
        </code>
      
        output: I have 3 apples
        </pre>
      </div>
      <br />

      <p>
        The code above is simple and easy to understand, right? Even for a
        non-technical person. But to a computer, this syntax is essentially
        gibberish — because it only understands
        <span class="color-green">1s and 0s</span>.
      </p>
      <br />
      <p>
        The solution is to find a way to make the computer understand our
        "gibberish". That means we need a method to convert our code into
        <span class="color-green">1s and 0s</span> — machine language.
      </p>

      <br /><br />

      <h1 id="understanding-compilers">Understanding Compilers</h1>
      <hr />
      <br />

      <p>
        One way to convert our code into machine-readable language is by using a
        compiler.
      </p>
      <br />
      <p>
        Let’s use a restaurant analogy. Imagine you're in a restaurant. A waiter
        approaches and hands you a pen and a piece of paper to write down your
        order. You write:
      </p>

      <br />
      <pre class="order-card"> 
        <p>Order List</p>
        <ul>
          <li>Sharwama + beef</li>
          <li>A large piece of bread</li>
          <li>Honey and butter</li>
          <li>Pizza and spaghetti</li>
          <li>Medium fried liver</li>
          <li>Fufu and garri...</li>
        </ul>
      </pre>
      <br />

      <p>
        Since the waiter in this case represents a compiler, he takes the entire
        order list, gives it to the chef to prepare everything at once, and then
        brings you the full meal. That’s pretty fast, right? Because all your
        orders are processed in one go.
      </p>
      <br />
      <p>
        Similarly, when using a compiled language, your code is first converted
        into an executable file — <span class="color-green">1s and 0s</span> —
        and then you get your output.
      </p>

      <br /><br />

      <h1 id="understanding-interpreters">Understanding Interpreters</h1>
      <hr />
      <br />

      <p>
        An interpreter is another interesting way to convert code to binary
        (machine language). Let's go back to our restaurant analogy to
        understand it better.
      </p>
      <br />
      <p>
        Once again, you're at a restaurant and a waiter hands you a pen and a
        piece of paper to write down your order:
      </p>

      <br />
      <pre class="order-card"> 
        <p>Order List</p>
        <ul>
          <li>Biscuit</li>
          <li>Bread</li>
          <li>Yam</li>
        </ul>
      </pre>
      <br />

      <p>
        This time, since you're dealing with an interpreter-type waiter, the
        process changes. He will take the first order (biscuit), give it to the
        chef to prepare, deliver it to you, then go back for the second one, and
        so on — processing one item at a time. It's clearly slower than the
        compiler waiter, who processed everything at once.
      </p>
      <br />
      <p>
        In short, an interpreted language processes your code line by line every
        time you run it.
      </p>

      <br /><br />

      <h1 id="translation-process">Translation Process</h1>
      <hr />
      <br />

      <p>
        So how does the actual translation happen? The process involves three
        key stages:
      </p>
      <br />

      <p>
        <strong>#1 Analysis</strong><br />
        An interpreter or compiler analyzes your code for syntax errors.
      </p>
      <br />
      <p>
        <strong>#2 Optimization</strong><br />
        The code is then optimized for better structure and memory efficiency.
      </p>
      <br />
      <p>
        <strong>#3 Conversion</strong><br />
        - If you're using a compiler, the code is converted into bytecode, which
        is compatible across hardware types. This bytecode is then turned into
        an executable file — <span class="color-green">1s and 0s</span>.
        <br /><br />
        - Once compiled, the program doesn’t need to reprocess anything. It
        simply runs instantly.
      </p>
      <br />
      <p>
        - If you're using an interpreter, your code is translated into machine
        language line by line — every time you execute it.
      </p>

      <!-- #embed that video yt + credit or just a link -->

      <br /><br />

      <h1 id="pros-cons">Pros & Cons: Compiler vs Interpreter</h1>
      <hr />
      <br />

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Feature</th>
            <th>Compiler</th>
            <th>Interpreter</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Execution speed</td>
            <td>Faster (entire code compiled once)</td>
            <td>Slower (line by line execution)</td>
          </tr>
          <tr>
            <td>Memory usage</td>
            <td>Higher (needs to store entire compiled program)</td>
            <td>Lower (only loads what's currently needed)</td>
          </tr>
          <tr>
            <td>Error handling</td>
            <td>All errors found before execution</td>
            <td>Stops at first error during execution</td>
          </tr>
          <tr>
            <td>Debugging</td>
            <td>More difficult (separate compilation step)</td>
            <td>Easier (immediate feedback)</td>
          </tr>
          <tr>
            <td>Flexibility</td>
            <td>Less flexible (needs recompilation)</td>
            <td>More flexible (can change code on the fly)</td>
          </tr>
          <tr>
            <td>Optimization</td>
            <td>Better (more time to optimize)</td>
            <td>Limited (optimizes on the go)</td>
          </tr>
          <tr>
            <td>Real-time execution</td>
            <td>No (compilation step first)</td>
            <td>Yes (immediate execution)</td>
          </tr>
        </tbody>
      </table>
      <br /><br />
      <h1 id="use-cases">Use Cases</h1>
      <hr />
      <br />

      <h1 id="compilers-use-cases">Compilers Use Cases</h1>
      <hr />
      <br />

      <p>
        When should you use
        <a
          href="https://en.wikipedia.org/wiki/Compiled_language"
          target="_blank"
          title="Compiled languages convert source code to machine code before execution"
          >compiled languages</a
        >? Here are the main situations:
      </p>
      <br />

      <ul>
        <li>
          <strong>Speed matters</strong>: Games,
          <a
            href="https://en.wikipedia.org/wiki/Operating_system"
            target="_blank"
            title="Software that manages computer hardware and software resources"
            >operating systems</a
          >, and other performance-critical software
        </li>
        <li>
          <strong>Limited resources</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Embedded_system"
            target="_blank"
            title="Computing systems built into devices with specific functions"
            >Embedded systems</a
          >
          and
          <a
            href="https://en.wikipedia.org/wiki/Internet_of_things"
            target="_blank"
            title="Internet of Things - connected smart devices"
            >IoT devices</a
          >
          with minimal memory
        </li>
        <li>
          <strong>Distributing software</strong>: When you want users to run
          your program without seeing your code
        </li>
      </ul>

      <br />
      <p>Common compiled languages: C, C++, Rust, Go</p>

      <br /><br />

      <h1 id="interpreters-use-cases">Interpreters Use Cases</h1>
      <hr />
      <br />

      <p>
        When should you use
        <a
          href="https://en.wikipedia.org/wiki/Interpreter_(computing)"
          target="_blank"
          title="Interpreters execute code line by line at runtime"
          >interpreted</a
        >
        languages? Here are the main situations:
      </p>
      <br />

      <ul>
        <li>
          <strong>Quick development</strong>: Web development,
          <a
            href="https://en.wikipedia.org/wiki/Software_prototyping"
            target="_blank"
            title="Creating preliminary versions to test concepts"
            >prototyping</a
          >, when you need to test ideas fast
        </li>
        <li>
          <strong>Learning to code</strong>: Getting immediate feedback helps
          beginners
        </li>
        <li>
          <strong>Scripting</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Task_automation"
            target="_blank"
            title="Using code to automate repetitive tasks"
            >Automation</a
          >
          tasks and simple tools
        </li>
        <li>
          <strong>Cross-platform needs</strong>: When your code needs to run on
          different systems easily
        </li>
      </ul>

      <br />
      <p>Common interpreted languages: Python, JavaScript, Ruby, PHP</p>

      <br /><br />

      <h1 id="historical-context">Historical Context</h1>
      <hr />
      <br />

      <h1 id="origins-compilers-interpreters">The Origins and Evolution</h1>
      <hr />
      <br />

      <p>How did we get here? A quick history:</p>
      <br />

      <ul>
        <li>
          <strong>1950s</strong>: First compiler created by
          <a
            href="https://en.wikipedia.org/wiki/Grace_Hopper"
            target="_blank"
            title="Pioneer in computer programming and US Navy rear admiral"
            >Grace Hopper</a
          >
          for the A-0 programming language
        </li>
        <li>
          <strong>1957</strong>:
          <a
            href="https://en.wikipedia.org/wiki/Fortran"
            target="_blank"
            title="FORmula TRANslation - early high-level programming language"
            >FORTRAN</a
          >
          compiler released - first widely used high-level language
        </li>
        <li>
          <strong>1960s</strong>:
          <a
            href="https://en.wikipedia.org/wiki/BASIC"
            target="_blank"
            title="Beginner's All-purpose Symbolic Instruction Code"
            >BASIC</a
          >
          interpreter made programming accessible to more people
        </li>
        <li>
          <strong>1970s-80s</strong>:
          <a
            href="https://en.wikipedia.org/wiki/C_(programming_language)"
            target="_blank"
            title="General-purpose programming language"
            >C language</a
          >
          compiler became dominant for system programming
        </li>
        <li>
          <strong>1990s</strong>: Java introduced "compile once, run anywhere"
          with
          <a
            href="https://en.wikipedia.org/wiki/Bytecode"
            target="_blank"
            title="Intermediate code form between source code and machine code"
            >bytecode</a
          >
          and a
          <a
            href="https://en.wikipedia.org/wiki/Virtual_machine"
            target="_blank"
            title="Software that creates isolated environment for running programs"
            >virtual machine</a
          >
        </li>
        <li>
          <strong>2000s-now</strong>: Hybrid approaches becoming common (<a
            href="https://en.wikipedia.org/wiki/Just-in-time_compilation"
            target="_blank"
            title="Just-In-Time compilers that compile during execution"
            >JIT compilers</a
          >,
          <a
            href="https://en.wikipedia.org/wiki/Source-to-source_compiler"
            target="_blank"
            title="Tools that convert code from one language to another"
            >transpilers</a
          >)
        </li>
      </ul>

      <br /><br />

      <footer>
        <p class="continue-reading">
          Continue reading:
          <a href="howacomputerworks.html">How Do Computers Really Work?</a>
        </p>

        <p class="contribute">
          Want to contribute?
          <a
            href="https://github.com/HassanAmirii/premordium-the-foundation-of-code"
            target="_blank"
            rel="noopener noreferrer"
            title="Contribute on GitHub"
          >
            visit
            <img
              src="/asset/logos/github-logo-thin.png"
              alt="GitHub icon"
              width="20"
              height="20"
              style="vertical-align: middle; margin-left: 5px"
            />
          </a>
        </p>
        <p>
          made with &hearts; by <a href="hassan2bit.vercel.app">Hassan2bit</a>
        </p>
        <p>Premordium v1.0 2025</p>
      </footer>
    </div>
  </body>
</html>
